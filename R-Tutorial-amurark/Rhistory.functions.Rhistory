z <- seq(-20, 120, 0.1);
lines(z, dnorm(z, mean2, sd2) * 2000);
set.seed(123)
ans9_1 <- rnorm(100)
mean = mean(ans9_1)
mean
set.seed(123)
ans9_1 <- rnorm(100)
mean = mean(ans9_1)
mean
set.seed(123)
ans9_1 <- rnorm(100)
mean = mean(ans9_1)
sd = sd(ans9_1)
variance = var(ans9_1)
median = median(ans9_1)
quantile = quantile(ans9_1)
mean
sd
variance
median
quantile
hist(ans9_1, breaks = 10)
hist(ans9_1, breaks = 15)
hist(ans9_1, breaks = 15)
hist(ans9_1, breaks = 20)
hist(ans9_1, breaks = 25)
hist(ans9_1, breaks = 15)
qqnorm(ans9_1)
set.seed(123)
height = rnorm(100, 10, 5)
set.seed(150)
weight = rnorm(100, 50, 20)
ans9_4 = data.frame(height, weight)
colMeans(ans9_4)
sd(ans9_4[,1])
var(ans9_4[,1])
quantile(ans9_4[,1])
sd(ans9_4[,2])
var(ans9_4[,2])
quantile(ans9_4[,2])
hist(ans9_4[,1], xlab="Height")
hist(ans9_4[,2], xlab="Weight")
boxplot(ans9_4[,1], xlab="Height")
boxplot(ans9_4[,2], xlab="Weight")
plot(ans9_4, xlab="Height", ylab="Weight")
mean1 = mean(height)
sd1 = sd(height)
hist(height, xlab='Height');
z <- seq(-10, 25, 0.1);
lines(z, dnorm(z, mean1, sd1) * 400);
mean2 = mean(weight)
sd2 = sd(weight)
hist(weight, xlab='Weight');
z <- seq(-20, 120, 0.1);
lines(z, dnorm(z, mean2, sd2) * 2000);
mean2 = mean(weight)
sd2 = sd(weight)
hist(weight, xlab='Weight');
z <- seq(-20, 120, 0.1);
lines(z, dnorm(z, mean2, sd2) * 500);
mean2 = mean(weight)
sd2 = sd(weight)
hist(weight, xlab='Weight');
z <- seq(-20, 120, 0.1);
lines(z, dnorm(z, mean2, sd2) * 1000);
biv <- mvrnorm(1000, mu=c(mean(ans9_4[,1]), mean(ans9_4[,2])), Sigma=cov(ans9_4));
biv <- mvrnorm(1000, mu=c(mean(ans9_4[,1]), mean(ans9_4[,2])), Sigma=cov(ans9_4));
library(MASS)
biv <- mvrnorm(1000, mu=c(mean(ans9_4[,1]), mean(ans9_4[,2])), Sigma=cov(ans9_4));
kde <- kde2d(biv[,1], biv[,2], n = 50)
contour(kde)
points(ans9_4)
kde <- kde2d(biv[,1], biv[,2], n = 50, h=c(10, 10))
contour(kde)
points(ans9_4)
kde <- kde2d(biv[,1], biv[,2], n = 50, h=c(20, 20))
contour(kde)
kde <- kde2d(biv[,1], biv[,2], n = 50, h=c(15, 15))
contour(kde)
kde <- kde2d(biv[,1], biv[,2], n = 50, h=c(11, 12))
contour(kde)
kde <- kde2d(biv[,1], biv[,2], n = 50, h=c(14, 14))
contour(kde)
kde <- kde2d(biv[,1], biv[,2], n = 100, h=c(14, 14))
contour(kde)
points(ans9_4)
kde <- kde2d(biv[,1], biv[,2], n = 100, h=c(14, 14))
contour(kde)
points(ans9_4)
hist(ans9_1, breaks = 10)
hist(ans9_1, breaks = 15)
hist(ans9_1, breaks = 20)
hist(ans9_1, breaks = 25)
set.seed(123)
height = rnorm(100, 10, 5)
set.seed(150)
weight = rnorm(100, 50, 20)
ans9_4 = data.frame(height, weight)
colMeans(ans9_4)
sd(ans9_4[,1])
var(ans9_4[,1])
quantile(ans9_4[,1])
sd(ans9_4[,2])
var(ans9_4[,2])
quantile(ans9_4[,2])
hist(ans9_4[,1], xlab="Height")
hist(ans9_4[,2], xlab="Weight")
boxplot(ans9_4[,1], xlab="Height")
boxplot(ans9_4[,2], xlab="Weight")
plot(ans9_4, xlab="Height", ylab="Weight")
library(MASS)
biv <- mvrnorm(1000, mu=c(mean(ans9_4[,1]), mean(ans9_4[,2])), Sigma=cov(ans9_4));
kde <- kde2d(biv[,1], biv[,2], n = 100, h=c(14, 14))
contour(kde)
points(ans9_4)
set.seed(123)
height = rnorm(100, 10, 5)
set.seed(150)
weight = rnorm(100, 50, 20)
mean1 = mean(height)
sd1 = sd(height)
hist(height, xlab='Height');
z <- seq(-10, 25, 0.1);
lines(z, dnorm(z, mean1, sd1) * 400);
mean2 = mean(weight)
sd2 = sd(weight)
hist(weight, xlab='Weight');
z <- seq(-20, 120, 0.1);
lines(z, dnorm(z, mean2, sd2) * 1000);
hist(ans9_1, breaks = 20)
set.seed(123)
ans9_1 <- rnorm(100)
hist(ans9_1, breaks = 10)
hist(ans9_1, breaks = 15)
hist(ans9_1, breaks = 20)
hist(ans9_1, breaks = 25)
set.seed(123)
height = rnorm(100, 10, 5)
set.seed(150)
weight = rnorm(100, 50, 20)
ans9_4 = data.frame(height, weight)
library(MASS)
biv <- mvrnorm(1000, mu=c(mean(ans9_4[,1]), mean(ans9_4[,2])), Sigma=cov(ans9_4));
kde <- kde2d(biv[,1], biv[,2], n = 100, h=c(14, 14))
contour(kde)
points(ans9_4)
x => c(6,4,6,9,3,9,6,3,9,5,3,9)
x = c(6,4,6,9,3,9,6,3,9,5,3,9)
y = c(520, 421, 581, 632, 412, 562, 432, 443, 590, 570, 348, 672)
plot(x,y)
x <- c(6,4,6,9,3,9,6,3,9,5,3,9)
y <- c(520, 421, 581, 632, 412, 562, 432, 443, 590, 570, 348, 672)
abline(308.1617, 34.5147)
plot(x,y)
CoinFlip <- function(){
n <- 0
allflips <- runif(10000)
repeatnum <- rep(0, 10000)
i <- 1
while(i <= 10000)
{
if(allflips[i] <= 0.5)
{
n = n + 1
}
repeatnum[i] = n/i
i <- i + 1;
}
plot(repeatnum)
}
CoinFlip()
CLT <- function(type, sampleSize)
{
allSamples <- rep(0, sampleSize)
if(type == 'Uniform')
{
samples <- runif(sampleSize)
}
else if(dist == 'Normal')
{
samples <- rnorm(sampleSize, mean = 10, sd = 5)
}
else
{
paste0('Please enter either Uniform or Normal distribution')
}
hist(samples, 10)
}
CLT('Normal', 100)
CLT('Normal', 100)
CLT <- function(typed, sampleSize)
{
allSamples <- rep(0, sampleSize)
if(typed == 'Uniform')
{
samples <- runif(sampleSize)
}
else if(typed == 'Normal')
{
samples <- rnorm(sampleSize, mean = 10, sd = 5)
}
else
{
paste0('Please enter either Uniform or Normal distribution')
}
hist(samples, 10)
}
CLT('Normal', 100)
CoinFlip <- function()
{
coinFlips <- runif(10000)
tails <- 0
tailDis <- rep(0, 10000)
for (i in 1:10000)
{
if(coinFlips[i] <= 0.5)
{
tails = tails + 1
}
tailDis[i] = tails/i
}
plot(tailDis)
}
CoinFlip()
CLT <- function(typed, sampleSize)
{
allSamples <- rep(0, sampleSize)
if(typed == 'Uniform')
{
samples <- runif(sampleSize)
}
else if(typed == 'Normal')
{
samples <- rnorm(sampleSize, mean = 10, sd = 5)
}
else
{
paste0('Please enter either Uniform or Normal distribution')
}
hist(samples, 10)
}
CLT('Normal', 100)
CLT <- function(typed, sampleSize, noSamples)
{
allSamples <- rep(1, noSamples)
if(typed == 'Uniform')
{
for(i in 1:noSample)
{
x=runif(sampleSize, min = 90, max = 110);
allSamples[i]=mean(x)
}
hist(allSamples,prob=TRUE,breaks=12,xlim=c(90,110),xlab = "Sampling distribution from Uniform population");
}
else if(typed == 'Normal')
{
for(i in 1:noSample)
{
x=rnorm(n = sampleSize, mean = 100, sd = 10);
allSamples[i]=mean(x);
}
hist(xbar,prob=TRUE,breaks=12,xlim=c(70,130),xlab = "Sampling distribution from Normal population");
}
else
{
paste0('Please enter either Uniform or Normal distribution')
}
hist(samples, 10)
}
CLT('Normal', 30, 100)
CLT <- function(typed, sampleSize, noSample)
{
allSamples <- rep(1, noSample)
if(typed == 'Uniform')
{
for(i in 1:noSample)
{
x=runif(sampleSize, min = 90, max = 110);
allSamples[i]=mean(x)
}
hist(allSamples,prob=TRUE,breaks=12,xlim=c(90,110),xlab = "Sampling distribution from Uniform population");
}
else if(typed == 'Normal')
{
for(i in 1:noSample)
{
x=rnorm(n = sampleSize, mean = 100, sd = 10);
allSamples[i]=mean(x);
}
hist(xbar,prob=TRUE,breaks=12,xlim=c(70,130),xlab = "Sampling distribution from Normal population");
}
else
{
paste0('Please enter either Uniform or Normal distribution')
}
hist(samples, 10)
}
CLT('Normal', 30, 100)
CLT <- function(typed, sampleSize, noSample)
{
allSamples <- rep(1, noSample)
if(typed == 'Uniform')
{
for(i in 1:noSample)
{
x=runif(sampleSize, min = 90, max = 110);
allSamples[i]=mean(x)
}
hist(allSamples,prob=TRUE,breaks=12,xlim=c(90,110),xlab = "Sampling distribution from Uniform population");
}
else if(typed == 'Normal')
{
for(i in 1:noSample)
{
x=rnorm(n = sampleSize, mean = 100, sd = 10);
allSamples[i]=mean(x);
}
hist(allSamples,prob=TRUE,breaks=12,xlim=c(70,130),xlab = "Sampling distribution from Normal population");
}
else
{
paste0('Please enter either Uniform or Normal distribution')
}
hist(samples, 10)
}
CLT('Normal', 30, 100)
CLT('Uniform', 30, 100)
#Load the necessary packages
library("ISLR")
install.packages("ISLR");
library("ISLR")
attach(Default)
glm.fit = glm(formula = default ~ balance + income, family = binomial, data = Default)
coef(glm.fit)
size = dim(Default[1])[1]
train = sample(size, size/2)
test = Default[-train,]
glm.fit.training = glm(default ~ balance + income, family = binomial, data = Default, subset = train)
glm.probs = predict(glm.fit.training,newdata = test, type = "response")
glm.pred = rep("No",size/2)
glm.pred[glm.probs>0.5]="Yes"
glm.pred[glm.probs>0.5]="Yes"
table(glm.pred, test$default)
library("ISLR")
attach(Default)
glm.fit = glm(formula = default ~ balance + income, family = binomial, data = Default)
coef(glm.fit)
size = dim(Default[1])[1]
train = sample(size, size/2)
glm.fit.training = glm(default ~ balance + income, family = binomial, data = Default, subset = train)
test = Default[-train,]
glm.probs = predict(glm.fit.training,newdata = test, type = "response")
glm.pred = rep("No",size/2)
glm.pred[glm.probs>0.5]="Yes"
table(glm.pred, test$default)
mean(glm.pred != test$default)
table(glm.pred, test$default)
mean(glm.pred != test$default)
table(glm.pred, test$default)
mean(glm.pred != test$default)
#install.packages("ISLR")
library("ISLR")
attach(Default)
#Fit a logistic regression model that uses income and balance to predict default
glm.fit = glm(formula = default ~ balance + income, family = binomial, data = Default)
coef(glm.fit)
#Caculate the dimensions and store training and test datasets
size = dim(Default[1])[1]
train = sample(size, size/2)
#Fitting the model only using the training set
glm.fit.training = glm(default ~ balance + income, family = binomial, data = Default, subset = train)
test = Default[-train,]
#Obtaining the default status for each individual in validation by calculateing posterior probability
glm.probs = predict(glm.fit.training,newdata = test, type = "response")
glm.pred = rep("No",size/2)
glm.pred[glm.probs>0.5]="Yes"
#Computing validation set error by first creating the confusion matrix
table(glm.pred, test$default)
mean(glm.pred != test$default)
#install.packages("ISLR")
library("ISLR")
attach(Default)
#Fit a logistic regression model that uses income and balance to predict default
glm.fit = glm(formula = default ~ balance + income, family = binomial, data = Default)
coef(glm.fit)
#Caculate the dimensions and store training and test datasets
size = dim(Default[1])[1]
train = sample(size, size/2)
#Fitting the model only using the training set
glm.fit.training = glm(default ~ balance + income, family = binomial, data = Default, subset = train)
test = Default[-train,]
#Obtaining the default status for each individual in validation by calculateing posterior probability
glm.probs = predict(glm.fit.training,newdata = test, type = "response")
glm.pred = rep("No",size/2)
glm.pred[glm.probs>0.5]="Yes"
#Computing validation set error by first creating the confusion matrix
table(glm.pred, test$default)
mean(glm.pred != test$default)
#install.packages("ISLR")
library("ISLR")
attach(Default)
#Fit a logistic regression model that uses income and balance to predict default
glm.fit = glm(formula = default ~ balance + income, family = binomial, data = Default)
coef(glm.fit)
#Caculate the dimensions and store training and test datasets
size = dim(Default[1])[1]
train = sample(size, size/2)
#Fitting the model only using the training set
glm.fit.training = glm(default ~ balance + income, family = binomial, data = Default, subset = train)
test = Default[-train,]
#Obtaining the default status for each individual in validation by calculateing posterior probability
glm.probs = predict(glm.fit.training,newdata = test, type = "response")
glm.pred = rep("No",size/2)
glm.pred[glm.probs>0.5]="Yes"
#Computing validation set error by first creating the confusion matrix
table(glm.pred, test$default)
mean(glm.pred != test$default)
#install.packages("ISLR")
library("ISLR")
attach(Default)
#Fit a logistic regression model that uses income and balance to predict default
glm.fit = glm(formula = default ~ balance + income, family = binomial, data = Default)
coef(glm.fit)
#Caculate the dimensions and store training and test datasets
size = dim(Default[1])[1]
train = sample(size, size/2)
#Fitting the model only using the training set
glm.fit.training = glm(default ~ balance + income, family = binomial, data = Default, subset = train)
test = Default[-train,]
#Obtaining the default status for each individual in validation by calculateing posterior probability
glm.probs = predict(glm.fit.training,newdata = test, type = "response")
glm.pred = rep("No",size/2)
glm.pred[glm.probs>0.5]="Yes"
#Computing validation set error by first creating the confusion matrix
table(glm.pred, test$default)
mean(glm.pred != test$default)
#Please install ISLR if not already installed
#install.packages("ISLR")
library("ISLR")
attach(Default)
#Fit a logistic regression model that uses income and balance to predict default
glm.fit = glm(formula = default ~ balance + income, family = binomial, data = Default)
coef(glm.fit)
#Caculate the dimensions and store training and test datasets
size = dim(Default[1])[1]
train = sample(size, size/2)
#Fitting the model only using the training set
glm.fit.training = glm(default ~ balance + income + student, family = binomial, data = Default, subset = train)
test = Default[-train,]
#Obtaining the default status for each individual in validation by calculateing posterior probability
glm.probs = predict(glm.fit.training,newdata = test, type = "response")
glm.pred = rep("No",size/2)
glm.pred[glm.probs>0.5]="Yes"
#Computing validation set error by first creating the confusion matrix
table(glm.pred, test$default)
mean(glm.pred != test$default)
#Please install ISLR if not already installed
#install.packages("ISLR")
library("ISLR")
attach(Default)
#Fit a logistic regression model that uses income and balance to predict default
glm.fit = glm(formula = default ~ balance + income, family = binomial, data = Default)
coef(glm.fit)
#Caculate the dimensions and store training and test datasets
size = dim(Default[1])[1]
train = sample(size, size/2)
#Fitting the model only using the training set
glm.fit.training = glm(default ~ balance + income + student, family = binomial, data = Default, subset = train)
test = Default[-train,]
#Obtaining the default status for each individual in validation by calculateing posterior probability
glm.probs = predict(glm.fit.training,newdata = test, type = "response")
glm.pred = rep("No",size/2)
glm.pred[glm.probs>0.5]="Yes"
#Computing validation set error by first creating the confusion matrix
table(glm.pred, test$default)
mean(glm.pred != test$default)
library(swirl)
install.packages("swirl")
library(swirl)
swirl()
Sys.Date()
mean(c(2,4,5))
submit()
boring_function("My first function!")
boring_function
submit()
my_mean(c(4,5,10))
submit()
remainder(5)
remainder(11, 5)
remainder(divisor = 11, num = 5)
remainder(4, div = 2)
args(remainder)
submit()
evaluate(sd, c(1.4, 3.6, 7.9, 8.8))
evaluate(function(x){x+1}, 6)
evaluate(function(x){x[1]}, c(8,4,0))
evaluate(function(x){x[-1]}, c(8,4,0))
?paste
paste("Programming", "is", "fun!")
submit()
submit()
telegram("Good Morning")
submit()
info
info()
mad_libs(noun = "CCTV Camera", adjective = "numerous", place = "Timbukto")
submit()
'I' %p% 'love' %p% 'R!'
save.image("~/Desktop/NKIT/Rhostory.functions.RData")
savehistory("~/Desktop/NKIT/Rhistory.functions.Rhistory")
